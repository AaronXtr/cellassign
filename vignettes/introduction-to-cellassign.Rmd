---
title: "Assigning single-cells to known cell types with cellassign"
author: "Kieran R Campbell and Allen Zhang"
date: "April 2018"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

CellAssign vignette skeleton. Missing descriptions for several components -- to be added over the next while. 

```{r}
library(tidyverse)
library(scater)
library(splatter)
library(edgeR)
library(cellassign)
```

## Example data

We'll use example data generated by the `splatter` package. 

```{r}
data(example_sce, package = "cellassign")
```

This is a bit of a contrived example -- the marker genes are VERY highly overexpressed in each group. 

We can look at the true group assignments:

```{r}
colData(example_sce)$Group %>% table
```

## Constructing a marker gene matrix 

The next step is to construct a binary marker gene matrix that expresses our *a priori* knowledge of cell types.

Since we're using simulated data, we can pick genes that we made to be group-specific markers. 

```{r}
rowdat <- rowData(example_sce)

markers_group1 <- rowdat %>% as.data.frame %>% dplyr::filter(DEFacGroup1 > 1.3)
markers_group2 <- rowdat %>% as.data.frame %>% dplyr::filter(DEFacGroup2 > 1.3)
```

Next, we'll pick a few of these for each group, so as to not give CellAssign all the information. 

```{r}
set.seed(4242)
genes1 <- as.character(sample(markers_group1$Gene, size = 5))
genes2 <- as.character(sample(markers_group2$Gene, size = 5))
```

```{r}
marker_list <- list(
  'Group1'=genes1,
  'Group2'=genes2
)
```

We can conveniently convert this list into a binary matrix. 

```{r}
rho <- marker_list_to_mat(marker_list, include_other = FALSE)
```

Note that we have explicitly specified to not include an other class here (the default is to include one). 

## Running CellAssign

### Compute size factors

```{r}
sizeFactors(example_sce) <- edgeR::calcNormFactors(as.matrix(counts(example_sce)), method = "TMM")

s <- sizeFactors(example_sce)
```

### Extract expression matrix

```{r}
Y <- t(counts(example_sce))[,rownames(rho)]
```

### Run CellAssign (EM)

The following line runs the EM version of CellAssign with 2 random initializations and celltype-specific dispersion values. 

```{r}
em_result <- cellassign(exprs_obj = Y, rho = rho, s = s, X = NULL, data_type = "RNAseq", n_batches = 1, num_runs = 2, learning_rate = 1e-3, inference_method = "EM", phi_type = "cluster_specific")
```

```{r}
em_result$cell_type %>% table
```

```{r}
example_sce <- example_sce %>% scater::mutate(EM_group=em_result$cell_type)
```

```{r}
with(colData(example_sce), table(Group, EM_group))
```

### Run CellAssign (VB)

Variational Bayes is slower, but we can get an idea of the posteriors over our parameters (i.e. so we don't underestimate uncertainty). 

At the moment you can add priors to the $\delta$ parameters in VB. This could be implemented in EM too, but hasn't been. 

Note that this function doesn't return the entire posterior yet -- at the moment it returns similar values as the EM version. 

```{r}
vb_result <- cellassign(exprs_obj = Y, rho = rho, s = s, X = NULL, data_type = "RNAseq", n_batches = 1, num_runs = 1, learning_rate = 1e-3, inference_method = "VB")
```

```{r}
vb_result$cell_type %>% table
```

```{r}
example_sce <- example_sce %>% scater::mutate(VB_group=vb_result$cell_type)
```

```{r}
with(colData(example_sce), table(Group, VB_group))
```

### Concordance between EM and VB

```{r}
with(colData(example_sce), table(EM_group, VB_group))
```



