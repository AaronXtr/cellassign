---
title: "Assigning single-cells to known cell types with CellAssign"
author: "Allen W Zhang and Kieran R Campbell"
date: "December 2018"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Introduction to CellAssign}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warnings = FALSE,
  messages = FALSE,
  comment = "#>"
)
```

# Overview

`cellassign` assigns cells measured using single cell RNA sequencing to known cell types based on marker gene information. Unlike other supervised methods for assigning cell types from single cell RNA-seq data, `cellassign` does not require labeled single cell or bulk expression data -- `cellassign` only needs to know whether or not each given gene is a marker of each cell type. 

```{r, echo = FALSE, out.width = '50%'}
knitr::include_graphics("cellassign_schematic.png")
```

# Installation

`cellassign` depends on `tensorflow`, which can be installed as follows:

```{r, eval=FALSE}
install.packages("tensorflow")
library(tensorflow)
install_tensorflow()
```

You can confirm that the installation succeeded by running:

```{r, eval=FALSE}
sess = tf$Session()
hello <- tf$constant('Hello, TensorFlow!')
sess$run(hello)
```

For more details see the [Rstudio page on tensorflow installation](https://tensorflow.rstudio.com/tensorflow/articles/installation.html).

`cellassign` can then be installed using the `devtools` package via

```{r, eval=FALSE}
devtools::install_github("Irrationone/cellassign")
```

# Basic usage

```{r, results='hide', message=FALSE, warning=FALSE}
library(SingleCellExperiment)
library(cellassign)
```

## Example data

```{r}
data(example_sce)
data(example_rho)
```

```{r}
print(example_sce)
```

We can look at the true group assignments:

```{r}
table(colData(example_sce)$Group)
```

## Constructing a marker gene matrix 

The next step is to construct a binary marker gene matrix that expresses our *a priori* knowledge of cell types.

Since we're using simulated data, we can pick genes that we made to be group-specific markers. 

```{r}
# rowdat <- as.data.frame(rowData(example_sce))
# 
# markers_group1 <- dplyr::filter(rowdat, DEFacGroup1 > 1.3)
# markers_group2 <- dplyr::filter(rowdat, DEFacGroup2 > 1.3)
```

Next, we'll pick a few of these for each group, so as to not give CellAssign all the information. 

```{r}
# set.seed(4242)
# genes1 <- as.character(sample(markers_group1$Gene, size = 5))
# genes2 <- as.character(sample(markers_group2$Gene, size = 5))
```

```{r}
# marker_list <- list(
#   'Group1'=genes1,
#   'Group2'=genes2
# )
```

We can conveniently convert this list into a binary matrix. 

```{r}
# rho <- marker_list_to_mat(marker_list, include_other = FALSE)
```

Note that we have explicitly specified to not include an other class here (the default is to include one). 

## Running CellAssign

### Compute size factors

TODO: this is done to reduce size

```{r, eval=F}
norm_factors <- scran::computeSumFactors(example_sce)
lib_size_factors <- colSums(as.matrix(counts(example_sce)))

sizeFactors(example_sce) <- norm_factors * lib_size_factors / mean(norm_factors * lib_size_factors)

s <- sizeFactors(example_sce)
```

### Extract expression matrix

```{r, eval=FALSE}
Y <- t(counts(example_sce))[,rownames(rho)]
```

### Run CellAssign (EM)

The following line runs the EM version of CellAssign. 

```{r}
# devtools::load_all("../")

s <- sizeFactors(example_sce)

em_result <- cellassign(exprs_obj = example_sce, 
                        rho = example_rho, 
                        s = s, 
                        learning_rate = 1e-2, 
                        shrinkage = TRUE,
                        verbose = FALSE)
```

```{r}
table(em_result$cell_type)
```

```{r}
example_sce$EM_group <- em_result$cell_type
```

```{r}
with(colData(example_sce), table(Group, EM_group))
```





